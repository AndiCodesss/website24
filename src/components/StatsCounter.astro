---
const { stats } = Astro.props;
---

<div class="stats-grid">
  {stats.map((stat, index) => (
    <div class="stat-card" style={`animation-delay: ${index * 0.1}s`}>
      <div class="stat-value" data-value={stat.value}>{stat.value}</div>
      <div class="stat-label">{stat.label}</div>
      <div class="stat-glow"></div>
    </div>
  ))}
</div>

<style>
  .stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: var(--space-lg);
    margin: var(--space-xl) 0;
  }
  
  .stat-card {
    position: relative;
    background: var(--glass-bg);
    backdrop-filter: blur(10px);
    border: 1px solid var(--glass-border);
    border-radius: 20px;
    padding: var(--space-xl) var(--space-lg);
    text-align: center;
    opacity: 0;
    animation: fadeInUp 0.8s ease-out forwards;
    transition: all var(--transition-speed) ease;
    overflow: hidden;
  }
  
  @keyframes fadeInUp {
    from {
      opacity: 0;
      transform: translateY(20px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }
  
  .stat-glow {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 100px;
    height: 100px;
    background: radial-gradient(circle, rgba(59, 130, 246, 0.3) 0%, transparent 70%);
    transform: translate(-50%, -50%);
    opacity: 0;
    transition: all var(--transition-speed) ease;
  }
  
  .stat-card:hover {
    transform: translateY(-8px);
    box-shadow: 0 20px 40px rgba(59, 130, 246, 0.2);
    border-color: rgba(59, 130, 246, 0.3);
  }
  
  .stat-card:hover .stat-glow {
    opacity: 1;
    width: 200px;
    height: 200px;
  }
  
  .stat-value {
    font-size: clamp(2rem, 4vw, 3rem);
    font-weight: 800;
    background: var(--gradient-accent);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    margin-bottom: var(--space-sm);
    line-height: 1;
  }
  
  .stat-label {
    color: var(--color-text-secondary);
    font-size: 0.9rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }
  
  @media (max-width: 768px) {
    .stats-grid {
      grid-template-columns: repeat(2, 1fr);
    }
  }
</style>

<script>
  class StatsCounter {
    constructor() {
      this.observed = new Set();
      this.init();
    }
    
    init() {
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting && !this.observed.has(entry.target)) {
            this.observed.add(entry.target);
            this.animateValue(entry.target as HTMLElement);
          }
        });
      }, { threshold: 0.5 });
      
      document.querySelectorAll('.stat-value').forEach(stat => {
        observer.observe(stat);
      });
    }
    
    animateValue(element: HTMLElement) {
      const value = element.dataset.value || '0';
      const hasPlus = value.includes('+');
      const hasPercent = value.includes('%');
      const hasMillion = value.includes('M');
      
      let numericValue = parseInt(value.replace(/\D/g, ''));
      if (hasMillion) numericValue *= 1000000;
      
      const duration = 2000;
      const start = 0;
      const increment = numericValue / (duration / 16);
      let current = start;
      
      const timer = setInterval(() => {
        current += increment;
        if (current >= numericValue) {
          current = numericValue;
          clearInterval(timer);
        }
        
        let displayValue = Math.floor(current).toString();
        if (hasMillion) {
          displayValue = (current / 1000000).toFixed(0) + 'M';
        }
        if (hasPlus) displayValue += '+';
        if (hasPercent) displayValue += '%';
        
        element.textContent = displayValue;
      }, 16);
    }
  }
  
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => new StatsCounter());
  } else {
    new StatsCounter();
  }
</script>