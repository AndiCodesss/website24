---
const { text, className = "" } = Astro.props;
---

<div class="exploding-text-container">
  <h1 class={`exploding-text ${className}`} data-text={text}>
    {text.split('').map((char, index) => (
      <span class="char" data-index={index} style={`--char-index: ${index}`}>
        {char === ' ' ? '\u00A0' : char}
      </span>
    ))}
  </h1>
  <canvas class="particle-canvas"></canvas>
</div>

<style>
  .exploding-text-container {
    position: relative;
    display: inline-block;
    cursor: pointer;
  }
  
  .exploding-text {
    font-size: clamp(2rem, 5vw, 4rem);
    font-weight: 700;
    background: linear-gradient(135deg, #D4AF37 0%, #F4E5C2 50%, #D4AF37 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    text-transform: uppercase;
    letter-spacing: 2px;
    position: relative;
    display: inline-block;
    transition: filter 0.3s ease;
  }
  
  .exploding-text .char {
    display: inline-block;
    position: relative;
    transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    transform-origin: center;
  }
  
  .exploding-text:hover .char {
    animation: float 2s ease-in-out infinite;
    animation-delay: calc(var(--char-index) * 0.05s);
  }
  
  .exploding-text.exploded .char {
    opacity: 0;
    pointer-events: none;
  }
  
  @keyframes float {
    0%, 100% {
      transform: translateY(0) rotateZ(0deg);
    }
    50% {
      transform: translateY(-10px) rotateZ(5deg);
    }
  }
  
  .particle-canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 10;
  }
  
  /* 3D depth effect on hover */
  .exploding-text:hover {
    filter: drop-shadow(0 0 20px rgba(212, 175, 55, 0.5));
  }
  
  .exploding-text:hover .char:nth-child(even) {
    transform: translateZ(20px) scale(1.1);
  }
  
  .exploding-text:hover .char:nth-child(odd) {
    transform: translateZ(-10px) scale(0.95);
  }
  
  @media (max-width: 768px) {
    .exploding-text {
      font-size: clamp(1.5rem, 4vw, 2.5rem);
    }
  }
</style>

<script>
  class ParticleExplosion {
    constructor(container) {
      this.container = container;
      this.text = container.querySelector('.exploding-text');
      this.canvas = container.querySelector('.particle-canvas');
      this.ctx = this.canvas.getContext('2d');
      this.particles = [];
      this.isExploded = false;
      this.chars = container.querySelectorAll('.char');
      
      this.init();
    }
    
    init() {
      this.resizeCanvas();
      window.addEventListener('resize', () => this.resizeCanvas());
      
      this.text.addEventListener('click', (e) => {
        if (!this.isExploded) {
          this.explode(e);
        } else {
          this.reassemble();
        }
      });
      
      // Auto-reassemble after 3 seconds
      this.text.addEventListener('mouseleave', () => {
        if (this.isExploded) {
          setTimeout(() => this.reassemble(), 1500);
        }
      });
    }
    
    resizeCanvas() {
      const rect = this.container.getBoundingClientRect();
      this.canvas.width = window.innerWidth;
      this.canvas.height = window.innerHeight;
      this.canvas.style.position = 'fixed';
      this.canvas.style.top = '0';
      this.canvas.style.left = '0';
    }
    
    explode(event) {
      this.isExploded = true;
      this.text.classList.add('exploded');
      
      // Create particles for each character
      this.chars.forEach((char, index) => {
        const rect = char.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        
        // Create multiple particles per character
        for (let i = 0; i < 10; i++) {
          this.particles.push(new Particle(
            centerX,
            centerY,
            char.textContent,
            index
          ));
        }
      });
      
      this.animate();
    }
    
    reassemble() {
      this.isExploded = false;
      
      // Animate particles back
      this.particles.forEach((particle, index) => {
        const charIndex = particle.charIndex;
        const char = this.chars[charIndex];
        if (char) {
          const rect = char.getBoundingClientRect();
          particle.targetX = rect.left + rect.width / 2;
          particle.targetY = rect.top + rect.height / 2;
          particle.returning = true;
        }
      });
      
      setTimeout(() => {
        this.text.classList.remove('exploded');
        this.particles = [];
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      }, 500);
    }
    
    animate() {
      if (this.particles.length === 0) return;
      
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      
      this.particles = this.particles.filter(particle => {
        particle.update();
        particle.draw(this.ctx);
        return particle.life > 0;
      });
      
      requestAnimationFrame(() => this.animate());
    }
  }
  
  class Particle {
    constructor(x, y, char, charIndex) {
      this.x = x;
      this.y = y;
      this.char = char;
      this.charIndex = charIndex;
      this.vx = (Math.random() - 0.5) * 15;
      this.vy = (Math.random() - 0.5) * 15 - 5;
      this.gravity = 0.5;
      this.friction = 0.99;
      this.life = 1;
      this.decay = 0.01;
      this.size = Math.random() * 3 + 1;
      this.rotation = Math.random() * Math.PI * 2;
      this.rotationSpeed = (Math.random() - 0.5) * 0.4;
      this.returning = false;
      this.targetX = x;
      this.targetY = y;
      
      // Gold color variations
      const goldColors = ['#D4AF37', '#F4E5C2', '#B8941F', '#FFD700'];
      this.color = goldColors[Math.floor(Math.random() * goldColors.length)];
    }
    
    update() {
      if (this.returning) {
        // Move towards target position
        const dx = this.targetX - this.x;
        const dy = this.targetY - this.y;
        this.x += dx * 0.1;
        this.y += dy * 0.1;
        this.life -= this.decay * 2;
      } else {
        // Normal explosion physics
        this.vy += this.gravity;
        this.vx *= this.friction;
        this.vy *= this.friction;
        this.x += this.vx;
        this.y += this.vy;
        this.rotation += this.rotationSpeed;
        this.life -= this.decay;
      }
    }
    
    draw(ctx) {
      ctx.save();
      ctx.globalAlpha = this.life;
      ctx.translate(this.x, this.y);
      ctx.rotate(this.rotation);
      
      // Draw glowing particle
      const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.size * 2);
      gradient.addColorStop(0, this.color);
      gradient.addColorStop(0.5, this.color + '88');
      gradient.addColorStop(1, 'transparent');
      
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(0, 0, this.size * 2, 0, Math.PI * 2);
      ctx.fill();
      
      // Draw character fragment
      if (Math.random() > 0.5) {
        ctx.fillStyle = this.color;
        ctx.font = `${this.size * 5}px Inter`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.char, 0, 0);
      }
      
      ctx.restore();
    }
  }
  
  // Initialize all exploding text elements
  document.addEventListener('DOMContentLoaded', () => {
    const containers = document.querySelectorAll('.exploding-text-container');
    containers.forEach(container => {
      new ParticleExplosion(container);
    });
  });
</script>