---
const { text, className = '', delay = 0 } = Astro.props;
---

<span class={`text-scramble ${className}`} data-text={text} data-delay={delay}>
  {text}
</span>

<style>
  .text-scramble {
    display: inline-block;
    position: relative;
    font-family: inherit;
    letter-spacing: 0.02em;
    transition: all 0.3s ease;
  }
  
  .text-scramble.scrambling {
    color: #D4AF37;
    text-shadow: 0 0 20px rgba(212, 175, 55, 0.5);
  }
  
  .text-scramble.scrambling::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(
      180deg,
      transparent 0%,
      rgba(212, 175, 55, 0.05) 50%,
      transparent 100%
    );
    animation: scanline 1.5s infinite;
    pointer-events: none;
  }
  
  @keyframes scanline {
    0% { transform: translateY(-100%); }
    100% { transform: translateY(100%); }
  }
  
  .text-scramble .char {
    display: inline-block;
    position: relative;
    color: inherit;
    transition: all 0.3s ease;
  }
  
  .text-scramble .char.revealed {
    color: inherit;
    text-shadow: none;
  }
  
  /* Fix for h1 elements - make characters visible with solid color */
  h1 .text-scramble .char.revealed {
    color: #D4AF37 !important;
    -webkit-text-fill-color: #D4AF37 !important;
    background: none !important;
  }
  
  .text-scramble .char.glitch {
    animation: glitchChar 0.2s infinite;
  }
  
  @keyframes glitchChar {
    0%, 100% { 
      transform: translateX(0);
      opacity: 1;
    }
    20% { 
      transform: translateX(-1px);
      opacity: 0.8;
    }
    40% { 
      transform: translateX(1px);
      opacity: 0.9;
    }
    60% { 
      transform: translateX(-0.5px);
      opacity: 0.85;
    }
    80% { 
      transform: translateX(0.5px);
      opacity: 0.95;
    }
  }
  
  .text-scramble.completed {
    text-shadow: none;
  }
  
  /* Apply gradient to the whole completed element */
  h1 .text-scramble.completed {
    background: var(--gradient-gold) !important;
    -webkit-background-clip: text !important;
    -webkit-text-fill-color: transparent !important;
    background-clip: text !important;
    display: inline-block !important;
  }
  
  /* But make sure the characters inside are visible */
  h1 .text-scramble.completed .char {
    background: none !important;
    -webkit-text-fill-color: inherit !important;
  }
  
  /* Keep gold for subtitle */
  p.hero-subtitle .text-scramble .char.revealed {
    color: var(--color-text-secondary) !important;
    -webkit-text-fill-color: var(--color-text-secondary) !important;
    background: none !important;
  }
</style>

<script>
  class TextScrambler {
    constructor(element) {
      this.element = element;
      this.text = element.dataset.text;
      this.delay = parseInt(element.dataset.delay) || 0;
      this.chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
      this.revealed = false;
      this.observer = null;
      
      this.init();
    }
    
    init() {
      // Set up intersection observer
      this.observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting && !this.revealed) {
            setTimeout(() => this.scramble(), this.delay);
            this.observer.disconnect();
          }
        });
      }, { threshold: 0.5 });
      
      this.observer.observe(this.element);
    }
    
    scramble() {
      console.log('Starting scramble for:', this.text, 'Element is in h1:', !!this.element.closest('h1'));
      this.element.classList.add('scrambling');
      this.revealed = true;
      
      // Replace text with individual character spans
      const chars = this.text.split('');
      this.element.innerHTML = chars.map((char, i) => 
        `<span class="char" data-char="${char}">${char}</span>`
      ).join('');
      
      const charElements = this.element.querySelectorAll('.char');
      // Increase duration for h1 elements (name), keep shorter for others
      const isName = !!this.element.closest('h1');
      const scrambleDuration = isName ? 2500 : 1500;  // 2.5 seconds for name, 1.5 for subtitle
      const charDelay = isName ? 50 : 30;  // Slower reveal for name
      let completedCount = 0;
      
      charElements.forEach((charEl, index) => {
        const originalChar = charEl.dataset.char;
        const startTime = Date.now() + index * charDelay;
        
        const scrambleChar = () => {
          const elapsed = Date.now() - startTime;
          
          if (elapsed < scrambleDuration) {
            // Scramble effect
            if (Math.random() < 0.1) {
              charEl.classList.add('glitch');
              setTimeout(() => charEl.classList.remove('glitch'), 100);
            }
            
            if (originalChar === ' ') {
              charEl.textContent = ' ';
            } else {
              charEl.textContent = this.chars[Math.floor(Math.random() * this.chars.length)];
            }
            
            requestAnimationFrame(scrambleChar);
          } else {
            // Reveal original character and keep it
            charEl.textContent = originalChar;
            charEl.classList.add('revealed');
            // Force gold color for h1 elements
            if (this.element.closest('h1')) {
              charEl.style.color = '#D4AF37';
              charEl.style.webkitTextFillColor = '#D4AF37';
            }
            completedCount++;
            
            // When all characters are revealed, clean up
            if (completedCount === charElements.length) {
              // Longer delay for h1 to enjoy the gold color before gradient
              const finalDelay = isName ? 500 : 300;
              setTimeout(() => {
                this.element.classList.remove('scrambling');
                this.element.classList.add('completed');
                // For h1 elements, restore the text to enable gradient
                const h1Parent = this.element.closest('h1');
                if (h1Parent) {
                  console.log('Restoring h1 text with gradient');
                  this.element.textContent = this.text;
                  // Force the gradient styles
                  this.element.style.background = 'linear-gradient(135deg, #D4AF37 0%, #F4E5C2 50%, #D4AF37 100%)';
                  this.element.style.webkitBackgroundClip = 'text';
                  this.element.style.webkitTextFillColor = 'transparent';
                  this.element.style.backgroundClip = 'text';
                  this.element.style.display = 'inline-block';
                }
              }, finalDelay);
            }
          }
        };
        
        scrambleChar();
      });
    }
  }
  
  // Initialize all text scramble elements
  document.addEventListener('DOMContentLoaded', () => {
    const elements = document.querySelectorAll('.text-scramble');
    elements.forEach(el => new TextScrambler(el));
  });
</script>