---
const { text, className = '', delay = 0 } = Astro.props;
---

<span class={`text-scramble ${className}`} data-text={text} data-delay={delay}>
  {text}
</span>

<style>
  .text-scramble {
    display: inline-block;
    position: relative;
    font-family: inherit;
    letter-spacing: 0.02em;
    transition: all 0.3s ease;
  }
  
  .text-scramble.scrambling {
    color: #D4AF37;
    text-shadow: 0 0 20px rgba(212, 175, 55, 0.5);
  }
  
  .text-scramble.scrambling::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(
      180deg,
      transparent 0%,
      rgba(212, 175, 55, 0.05) 50%,
      transparent 100%
    );
    animation: scanline 1.5s infinite;
    pointer-events: none;
  }
  
  @keyframes scanline {
    0% { transform: translateY(-100%); }
    100% { transform: translateY(100%); }
  }
  
  .text-scramble .char {
    display: inline-block;
    position: relative;
    color: inherit;
    transition: all 0.3s ease;
  }
  
  .text-scramble .char.revealed {
    color: inherit;
    text-shadow: none;
  }
  
  .text-scramble .char.glitch {
    animation: glitchChar 0.2s infinite;
  }
  
  @keyframes glitchChar {
    0%, 100% { 
      transform: translateX(0);
      opacity: 1;
    }
    20% { 
      transform: translateX(-1px);
      opacity: 0.8;
    }
    40% { 
      transform: translateX(1px);
      opacity: 0.9;
    }
    60% { 
      transform: translateX(-0.5px);
      opacity: 0.85;
    }
    80% { 
      transform: translateX(0.5px);
      opacity: 0.95;
    }
  }
  
  .text-scramble.completed {
    color: var(--color-white);
    text-shadow: none;
  }
</style>

<script>
  class TextScrambler {
    constructor(element) {
      this.element = element;
      this.text = element.dataset.text;
      this.delay = parseInt(element.dataset.delay) || 0;
      this.chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
      this.revealed = false;
      this.observer = null;
      
      this.init();
    }
    
    init() {
      // Set up intersection observer
      this.observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting && !this.revealed) {
            setTimeout(() => this.scramble(), this.delay);
            this.observer.disconnect();
          }
        });
      }, { threshold: 0.5 });
      
      this.observer.observe(this.element);
    }
    
    scramble() {
      this.element.classList.add('scrambling');
      this.revealed = true;
      
      // Replace text with individual character spans
      const chars = this.text.split('');
      this.element.innerHTML = chars.map((char, i) => 
        `<span class="char" data-char="${char}">${char}</span>`
      ).join('');
      
      const charElements = this.element.querySelectorAll('.char');
      const scrambleDuration = 1000;
      const charDelay = 30;
      let completedCount = 0;
      
      charElements.forEach((charEl, index) => {
        const originalChar = charEl.dataset.char;
        const startTime = Date.now() + index * charDelay;
        
        const scrambleChar = () => {
          const elapsed = Date.now() - startTime;
          
          if (elapsed < scrambleDuration) {
            // Scramble effect
            if (Math.random() < 0.1) {
              charEl.classList.add('glitch');
              setTimeout(() => charEl.classList.remove('glitch'), 100);
            }
            
            if (originalChar === ' ') {
              charEl.textContent = ' ';
            } else {
              charEl.textContent = this.chars[Math.floor(Math.random() * this.chars.length)];
            }
            
            requestAnimationFrame(scrambleChar);
          } else {
            // Reveal original character and keep it
            charEl.textContent = originalChar;
            charEl.classList.add('revealed');
            completedCount++;
            
            // When all characters are revealed, clean up
            if (completedCount === charElements.length) {
              setTimeout(() => {
                this.element.classList.remove('scrambling');
                this.element.classList.add('completed');
                // Restore the original text to ensure it stays visible
                this.element.textContent = this.text;
              }, 300);
            }
          }
        };
        
        scrambleChar();
      });
    }
  }
  
  // Initialize all text scramble elements
  document.addEventListener('DOMContentLoaded', () => {
    const elements = document.querySelectorAll('.text-scramble');
    elements.forEach(el => new TextScrambler(el));
  });
</script>